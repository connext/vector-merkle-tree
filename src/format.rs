use super::{hash, Bytes32, Error, Node};
use faster_hex::hex_decode;
use std::convert::TryInto;

/// Takes an encoded transfer state and produces a leaf node
pub(crate) fn hex_to_node(core_transfer_state: &str) -> Result<Node, Error> {
    if core_transfer_state.len() != 770 || &core_transfer_state[..2] != "0x" {
        return Err(Error::InvalidFormat);
    }
    let mut core_transfer_state_binary = [0u8; 384];
    hex_decode(
        &core_transfer_state[2..].as_bytes(),
        &mut core_transfer_state_binary,
    )
    .map_err(|_| Error::InvalidFormat)?;

    let hash = hash::keccak(&core_transfer_state_binary);
    let transfer_id = core_transfer_state_binary[32..64].try_into().unwrap();
    let node = Node { hash, transfer_id };
    Ok(node)
}

pub(crate) fn hex_encode(data: Bytes32) -> String {
    let mut s = "0".repeat(64);
    faster_hex::hex_encode(&data, unsafe { &mut s.as_bytes_mut() }).unwrap();
    s
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Verifies that the merkle leaves contain the same data as the TypeScript implementation.
    #[test]
    fn node_same_as_before() {
        let state = "0x000000000000000000000000ccc0000000000000000000000000000000000000364b4e94b854e94d5f35bf42698696b3064c91aaef39831bfd6c296aa6d1c33f000000000000000000000000def0000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001abcdef0000000000000000000000000000000000000000000000000000000000";
        let Node { transfer_id, hash } = hex_to_node(&state).unwrap();

        let hash = hex_encode(hash);
        let transfer_id = hex_encode(transfer_id);

        assert_eq!(
            hash,
            "8b50ff7d7ad3e4f693f210af3a2f025371d588c18d44a52bd7bdf610b1b1b799"
        );

        assert_eq!(
            transfer_id,
            "364b4e94b854e94d5f35bf42698696b3064c91aaef39831bfd6c296aa6d1c33f"
        );
    }

    #[test]
    fn errors() {
        // Invalid hex characters
        let state = "0xNOTHEX000000000000000000ccc0000000000000000000000000000000000000364b4e94b854e94d5f35bf42698696b3064c91aaef39831bfd6c296aa6d1c33f000000000000000000000000def0000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001abcdef0000000000000000000000000000000000000000000000000000000000";
        assert_eq!(Err(Error::InvalidFormat), hex_to_node(state));

        // Too many characters
        let state = "0x000000000000000000000000ccc0000000000000000000000000000000000000364b4e94b854e94d5f35bf42698696b3064c91aaef39831bfd6c296aa6d1c33f000000000000000000000000def0000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001abcdef000000000000000000000000000000000000000000000000000000000000";
        assert_eq!(Err(Error::InvalidFormat), hex_to_node(state));

        // Missing 0x
        let state = "000000000000000000000000ccc0000000000000000000000000000000000000364b4e94b854e94d5f35bf42698696b3064c91aaef39831bfd6c296aa6d1c33f000000000000000000000000def0000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000aa00000000000000000000000000000000000000000000000000000000000000bbb00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001abcdef000000000000000000000000000000000000000000000000000000000000";
        assert_eq!(Err(Error::InvalidFormat), hex_to_node(state));
    }
}
